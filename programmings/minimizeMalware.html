<!DOCTYPE html>
<html>
	<head>
		<title></title>
		<link rel="stylesheet" href="../styles.css">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="https://fonts.googleapis.com/css?family=Noto+Sans|Roboto+Mono&display=swap" rel="stylesheet">
		<meta charset="utf-8">
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		<script id="MathJax-script" async
		          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
	    <script src="https://unpkg.com/mathjs@7.2.0/dist/math.min.js"></script>
      <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

		<style>
      #mygraph {
        width: 700px;
        height: 700px;
        border: 1px solid lightgray;
        margin: 0 auto;
        background-color: coral;
      }
			table, td {
				background-color: coral;
				border: 1px solid black;
			}

      .table1{

      }
		</style>

	</head>

	<body>
		<h2>最小化恶意软件传播(Minimize Malware Spread)</h2>
    在一个网络中，一些INIT初始节点最初被恶意软件感染。每当两个节点直接连接并且两个节点中的至少一个受到恶意软件感染时，两个节点都将被恶意软件感染。
    恶意软件的传播将继续，直到无法再以这种方式感染更多节点为止。
    假设集 M(INIT) 是在恶意软件传播停止之后整个网络中感染了恶意软件的节点的最终数量。
    我们将从初始列表中删除一个节点，并将其以及从该节点到任何其他节点的所有连接完全删除。
    返回如果删除将最小化 M(INIT）的节点。如果可以删除多个节点以最小化 M(INIT)，请返回索引最小的此类节点。
    <br>
    <br>
    In a network of nodes,some set of nodes INIT are initially infected by malware.
    Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.
    This spread of malware will continue until no more nodes can be infected in this manner.
    Suppose M(INIT) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
    We will remove one node from the initial list, completely removing it and any connections from this node to any other node.
    Return the node that if removed, would minimize M(INIT).
    If multiple nodes could be removed to minimize M(INIT), return such a node with the smallest index.
    <br>
    例:
    <div class ="table1">
      <style type="text/css">
      .tg  {border-collapse:collapse;border-spacing:0;}
      .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        overflow:hidden;padding:10px 5px;word-break:normal;}
      .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
        font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
      .tg .tg-fv28{background-color: coral;border-color:#fe0000;text-align:left;vertical-align:top}
      </style>
      <table class="tg">
      <thead>
        <tr>
          <th class="tg-fv28">输入：</th>
          <th class="tg-fv28"><img src="../images/vsp1.jpg">
          </th>
        </tr>
        <tr>

        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="tg-fv28">输出:</td>
          <td class="tg-fv28">0</td>
        </tr>
        <tr>
          <td class="tg-fv28">说明:</td>
          <td class="tg-fv28">删除节点0，就只有1被感染。</td>
        </tr>
      </tbody>
      </table>
    </div>
    Example:
    <div>
      <table class="tg">
      <thead>
        <tr>
          <th class="tg-fv28">Input:</th>
          <th class="tg-fv28"><img src="../images/vsp2.jpg"></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="tg-fv28">Output:</td>
          <td class="tg-fv28">1</td>
        </tr>
        <tr>
          <td class="tg-fv28">Explanation:</td>
          <td class="tg-fv28">Delete node 1 and only node 0 will be infected</td>
        </tr>
      </tbody>
      </table>
    </div>
    <hr>
    <label for="tagEndA">边缘端A:(Edge end A)</label><br>
    <input type="text" id = "tagEndA" class="numbersonly" value="5"><br>
    <label for="tagEndB">边缘端B:(Edge End B)</label><br>
    <input type="text" id = "tagEndB" class="numbersonly" value="1"><br>
    <label for="tagHasV">有病毒吗,1是0否:(1 yes 0 no)</label><br>
    <input type="number" id = "tagHasV" class="numbersonly" value="1"><br>
    <input type="Button" onclick="AddNodee()" value="添加节点/边缘(Add Node/Edge)" /> <br>


    <table class="tg">
    <tbody>
      <tr>
        <td class="tg-fv28"><div id = "mygraph"></div></td>
      </tr>
      <tr>
        <td class="tg-fv28"><input type="Button" onclick="findMinNumberCuts()" value="找到要删除的最小节点数（find minimum number of nodes to remove)" /> <br></td>
      </tr>
    </tbody>
    </table>

    <div>
      <table id="tagOutput">
      </table>
    </div><br>

    <p> 讯息:(Message) <span id = "tagMessage"></span></p><br>

    <script>
      class ANetwork {
        constructor(divName) {
          this.divName = divName;
          this.namesValueDict = {};
          this.nodeIdSet = new Set();
          this.nodeNamesSet = new Set();
          this.namesIdDict = {};
          this.idNamesDict = {};
          // create an array with nodes
          this.nodeSet = new Set();
          this.nodes = new vis.DataSet([]);
          // create an array with edges
          this.edgesSet = new Set();
          this.edges = new vis.DataSet([]);
          // create a network
          this.container = document.getElementById(divName);
          this.data = {
            nodes: this.nodes,
            edges: this.edges,
          };
          this.options = {};
          this.network = new vis.Network(this.container, this.data, this.options);
        }
        displayAgain(){
          this.container = document.getElementById(this.divName);
          this.data = {
            nodes: this.nodes,
            edges: this.edges,
          };
          this.options = {};
          this.network = new vis.Network(this.container, this.data, this.options);
        }
        addNode(theLabel, profit){ // this method assume the label to be added dosen't exist in the network yet
          var tempId = Math.floor(Math.random() * 500);
          while(this.nodeIdSet.has(tempId)){
            tempId = Math.floor(Math.random() * 500);
          }
          if(!(this.nodeNamesSet.has(theLabel))){
            var nodeDisplayLabel = theLabel +":"+ profit;
            var tempNode = { id: tempId, label: nodeDisplayLabel };
            this.nodes.add(tempNode);
            this.network.stabilize();
            this.nodeIdSet.add(tempId);
            this.nodeSet.add(tempNode);
            this.namesIdDict[theLabel] = tempId;
            this.idNamesDict[tempId] = theLabel;
            this.namesValueDict[theLabel] = profit;
            this.nodeNamesSet.add(theLabel);
          }
        }
        removeNode(nodeId){

        }
        removeEdge(edgeId){
          this.edges.remove({id: edgeId})
        }
        addEdge(sLabel, dLabel){
          var tempEdge = { from: this.namesIdDict[sLabel], to: this.namesIdDict[dLabel], arrows: "to", label: "To be done before"};
          // console.log(getEdgeBetweenProjectNodes(projectNamesIdDict[sLabel],projectNamesIdDict[dLabel]));
          this.edges.add(tempEdge);
          this.edgesSet.add(tempEdge)
        }
        addLabelledEdge(sLabel, dLabel, capacity, flow, color){ // ann nodes needs to be preset before adding the edge
          var tempEdge = { from: this.namesIdDict[sLabel], to: this.namesIdDict[dLabel], arrows: "to", label: ""+flow+"/"+capacity, color: color};
          // console.log(getEdgeBetweenProjectNodes(projectNamesIdDict[sLabel],projectNamesIdDict[dLabel]));
          this.edges.add(tempEdge);
          this.edgesSet.add(tempEdge);

        }
        addResidueEdge(sLabel, dLabel, theLabel, color){ // ann nodes needs to be preset before adding the edge
          //console.log(theLabel);
          var tempEdge = { from: this.namesIdDict[sLabel], to: this.namesIdDict[dLabel], arrows: "to", label: theLabel+"", color: color};
          // console.log(getEdgeBetweenProjectNodes(projectNamesIdDict[sLabel],projectNamesIdDict[dLabel]));
          this.edges.add(tempEdge);
          this.edgesSet.add(tempEdge);
        }
        getEdgeBetweenNodes(node1_id,node2_id) {
          return this.edges.get().filter(function (edge) {
            return (edge.from === node1_id && edge.to === node2_id );
          });
        }
        getEdgesOfNode(nodeId) {
          return this.edges.get().filter(function (edge) {
            return edge.from === nodeId || edge.to === nodeId;
          });
        }
        getNodeByName(theName){
          return this.nodes.get(this.namesIdDict[theName]);
        }
        reset(){
          this.namesValueDict = {};
          this.nodeIdSet = new Set();
          this.nodeNamesSet = new Set();
          this.namesIdDict = {};
          this.idNamesDict = {};
          // create an array with nodes
          this.nodeSet = new Set();
          this.nodes = new vis.DataSet([]);
          // create an array with edges
          this.edgesSet = new Set();
          this.edges = new vis.DataSet([]);
          // create a network
          this.data = {
            nodes: this.nodes,
            edges: this.edges,
          };
          this.options = {};
          //this.network = new vis.Network(this.container, this.data, this.options);
          if (this.network != null) {
            this.network.destroy();
            this.network = new vis.Network(this.container, this.data, this.options);
          }
        }
      }
      var theNet = new ANetwork("mygraph");

      function AddNodee(){
        var tempLabelA = document.getElementById();
        var tempLabelB = document.getElementById();
      }

      function displayResult(){
        clearTable("tagOutput")
        var resultTbl = document.getElementById("tagOutput");
        var resultBody =  document.createElement("tbody");
        resultBody.appendChild(createTitleRow("我们向孩子们分发糖果的方法如下：(We distribute the candies to the children as follow)"));
        var longestSequenceStr = "["+resultList[0];
        var minimalValue = resultList[0];
        var kidRank = "["+inputNumbersList[0];
        for(var i = 1; i < resultList.length; i++){
          minimalValue = minimalValue+resultList[i];
          longestSequenceStr = longestSequenceStr + "," + resultList[i];
          kidRank = kidRank + "," + inputNumbersList[i];
        }
        longestSequenceStr = longestSequenceStr +"]";//globalMaxLength
        kidRank = kidRank +"]";
        resultBody.appendChild(createDescriptionRow("分发糖果给孩子们的方式是(The way to distribute of the candies to the children is)",longestSequenceStr));
        resultBody.appendChild(createDescriptionRow("孩子的评分值是(Rating values of the children is )",kidRank));
        resultBody.appendChild(createDescriptionRow("所需的最小糖果数量为(Minimum number of candy needed is )",minimalValue));
        resultTbl.append(resultBody);
      }
      function createDescriptionRow(label,description){
        var constraintRow = document.createElement("tr");
        constraintRow.appendChild(makecell(label));
        constraintRow.appendChild(makecell(description));
        return constraintRow;
      }
      function createTitleRow(str){
        var titleRow = document.createElement("tr");
        var titleCellTextNode = document.createTextNode(str);
        titleRow.appendChild(titleCellTextNode);
        return titleRow;
      }
      function clearTable(idstr){
        var makovTable = document.getElementById(idstr);
        while(makovTable.rows.length > 0) {
          makovTable.deleteRow(0);
        }
      }
      function makecell(str){
        var nameCell = document.createElement("td");
        var nameCellTextNode = document.createTextNode(str);
        nameCell.appendChild(nameCellTextNode);
        return nameCell;
      }

    </script>

	</body>
</html>
